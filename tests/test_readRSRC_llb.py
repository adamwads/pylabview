# -*- coding: utf-8 -*-

""" Test for pyLabview project, readRSRC script.

    This test extracts and then re-creates some RSRC files.
    Run it using `pytest` in project root folder.
"""

# Copyright (C) 2022 Mefistotelis <mefistotelis@gmail.com>
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

import filecmp
import glob
import itertools
import logging
import os
import re
import sys
import pathlib
import pytest
import xml.etree.ElementTree as ET
from unittest.mock import patch

# Import the functions to be tested
from pylabview.readRSRC import main as readRSRC_main


LOGGER = logging.getLogger(__name__)


@pytest.mark.parametrize("rsrc_inp_fn", itertools.chain.from_iterable([ glob.glob(e, recursive=True) for e in (
    './examples/**/*.vi',
    './examples/**/*.ctl',
    './examples/**/*.vit',
    './examples/**/*.mnu',
    './examples/**/*.ctt',
    './examples/**/*.uir',
    './examples/**/*.lsb',
    './examples/**/*.rsc',
  ) ]))
def test_readRSRC_repack_vi(rsrc_inp_fn):
    """ Test extraction and re-creation of VI/CTL/RSC files.

    VI files generated by the tool should be (with some exceptions, ie. older files which use
    random values for padding, or LLB files) same as original on binary level. Extracting and
    re-packing such file should result in receiving a binary-identical copy of the file.
    """
    # Only some files can be successfully tested in Python < 3.8, as XML parser was
    # improved in that version to preserve order of attributes.
    if sys.version_info < (3,8) and (
      rsrc_inp_fn.endswith("empty_vifile.vi")):
        pytest.skip("this file will not produce identical binary in python <= 3.8")

    rsrc_path, rsrc_filename = os.path.split(rsrc_inp_fn)
    rsrc_path = pathlib.Path(rsrc_path)
    rsrc_basename, rsrc_fileext = os.path.splitext(rsrc_filename)
    xml_fn = "{:s}.xml".format(rsrc_basename)
    if len(rsrc_path.parts) > 1:
        rsrc_out_path = os.sep.join(["test_out"] + list(rsrc_path.parts[1:]))
    else:
        rsrc_out_path = "test_out"
    rsrc_out_fn = os.sep.join([rsrc_out_path, "{:s}{:s}".format(rsrc_basename, rsrc_fileext)])
    single_vi_path_extr1 = os.sep.join([rsrc_out_path, "{:s}_extr1".format(rsrc_basename)])
    if not os.path.exists(single_vi_path_extr1):
        os.makedirs(single_vi_path_extr1)
    # Extract the VI file
    command = [os.path.join("pylabview", "readRSRC.py"), "-vv", "-x", "-i", rsrc_inp_fn, "-m", os.sep.join([single_vi_path_extr1, xml_fn])]
    with patch.object(sys, 'argv', command):
        readRSRC_main()
    # Re-create the VI file
    command = [os.path.join("pylabview", "readRSRC.py"), "-vv", "-c", "-m", os.sep.join([single_vi_path_extr1, xml_fn]), "-i", rsrc_out_fn]
    with patch.object(sys, 'argv', command):
        readRSRC_main()
    # Compare repackaged file and the original
    match =  filecmp.cmp(rsrc_inp_fn, rsrc_out_fn, shallow=False)
    assert match, "Re-created file different: {:s}".format(rsrc_inp_fn)


@pytest.mark.parametrize("rsrc_inp_fn", glob.glob(
    './examples/**/*.llb',
  recursive=True))
def test_readRSRC_repack_llb(rsrc_inp_fn):
    """ Test extraction and re-creation of LLB files.

    LLB files generated by the tool are NOT the same as original on binary level. That is because
    names section generation has time dependencies (not to mention in some old versions of LV, the
    padding is often filled with random data). So instead of comparing LLBs, compare the extracted
    files from first extraction and second extraction.
    """
    rsrc_path, rsrc_filename = os.path.split(rsrc_inp_fn)
    rsrc_path = pathlib.Path(rsrc_path)
    rsrc_basename, rsrc_fileext = os.path.splitext(rsrc_filename)
    xml_fn = "{:s}.xml".format(rsrc_basename)
    if len(rsrc_path.parts) > 1:
        rsrc_out_path = os.sep.join(["test_out"] + list(rsrc_path.parts[1:]))
    else:
        rsrc_out_path = "test_out"
    rsrc_out_fn = os.sep.join([rsrc_out_path, "{:s}{:s}".format(rsrc_basename, rsrc_fileext)])
    single_vi_path_extr1 = os.sep.join([rsrc_out_path, "{:s}_extr1".format(rsrc_basename)])
    if not os.path.exists(single_vi_path_extr1):
        os.makedirs(single_vi_path_extr1)
    single_vi_path_extr2 = os.sep.join([rsrc_out_path, "{:s}_extr2".format(rsrc_basename)])
    if not os.path.exists(single_vi_path_extr2):
        os.makedirs(single_vi_path_extr2)
    # Extract the LLB file
    command = [os.path.join("pylabview", "readRSRC.py"), "-vv", "-x", "--keep-names", "-i", rsrc_inp_fn, "-m", os.sep.join([single_vi_path_extr1, xml_fn])]
    with patch.object(sys, 'argv', command):
        readRSRC_main()
    # Re-create the LLB file
    command = [os.path.join("pylabview", "readRSRC.py"), "-vv", "-c", "-m", os.sep.join([single_vi_path_extr1, xml_fn]), "-i", rsrc_out_fn]
    with patch.object(sys, 'argv', command):
        readRSRC_main()
    # Check if re-created file size roughly matches the original
    rsrc_inp_fsize = os.path.getsize(rsrc_inp_fn)
    rsrc_out_fsize = os.path.getsize(rsrc_out_fn)
    assert rsrc_out_fsize >= int(rsrc_inp_fsize * 0.95), "Re-created file too small: {:s}".format(rsrc_inp_fn)
    assert rsrc_out_fsize <= int(rsrc_inp_fsize * 1.05), "Re-created file too large: {:s}".format(rsrc_inp_fn)

    # Re-extract the LLB file
    command = [os.path.join("pylabview", "readRSRC.py"), "-vv", "-x", "--keep-names", "-i", rsrc_out_fn, "-m", os.sep.join([single_vi_path_extr2, xml_fn])]
    with patch.object(sys, 'argv', command):
        readRSRC_main()
    # Compare files from first extraction to the ones from second extraction
    dirs_cmp = filecmp.dircmp(single_vi_path_extr1, single_vi_path_extr2)
    assert len(dirs_cmp.left_only) == 0, "Files exist only in 1st extraction: {:s}".format(', '.join(dirs_cmp.left_only))
    assert len(dirs_cmp.right_only) == 0, "Files exist only in 2nd extraction: {:s}".format(', '.join(dirs_cmp.right_only))
    assert len(dirs_cmp.funny_files) == 0, "Some funny files encountered: {:s}".format(', '.join(dirs_cmp.funny_files))
    (match, mismatch, errors) =  filecmp.cmpfiles(single_vi_path_extr1, single_vi_path_extr2, dirs_cmp.common_files, shallow=False)
    # Ignore some expected differences
    if len(mismatch) > 0:
        # Some LLB files contain ordering of items not supported by pylabview, resulting in different order of items in re-extracted XML
        # Ignore such XML differences, as it was a design decision to not care for ordering in such cases
        if xml_fn in mismatch:
            LOGGER.warning("XML not identical - ignoring expected ordering changes in extraction from: {}".format(rsrc_inp_fn))
            tree_extr1 = ET.parse(os.sep.join([single_vi_path_extr1, xml_fn]))
            tree_extr2 = ET.parse(os.sep.join([single_vi_path_extr2, xml_fn]))
            for root in [tree_extr1.getroot(), tree_extr2.getroot()]:
                for elem in root.findall('SpecialOrder'):
                    root.remove(elem)
            if hasattr( ET, "canonicalize" ):
                canonic_extr1 = ET.canonicalize(ET.tostring(tree_extr1.getroot()), strip_text=True)
                canonic_extr2 = ET.canonicalize(ET.tostring(tree_extr2.getroot()), strip_text=True)
            else:
                LOGGER.warning("The old Python does not have ET.canonicalize(), skipping")
                canonic_extr1 = ET.tostring(tree_extr1.getroot())
                canonic_extr2 = ET.tostring(tree_extr2.getroot())
            assert canonic_extr1 == canonic_extr2, "Re-extracted XML different even after ordering ignore: {:s}".format(xml_fn)
            mismatch = [fn for fn in mismatch if not fn.endswith(xml_fn)]

    assert len(mismatch) == 0, "Re-extracted files different: {:s}".format(', '.join(mismatch))
    assert len(errors) == 0, "Errors reading files: {:s}".format(', '.join(errors))
    # We should have an XML file and at least one extracted section file
    assert len(match) >= 2
